<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>GLM Documentation · GLM</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>GLM</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>GLM Documentation</a><ul class="internal"><li><a class="toctext" href="#Installation-1">Installation</a></li><li><a class="toctext" href="#Fitting-GLM-models-1">Fitting GLM models</a></li><li><a class="toctext" href="#Methods-applied-to-fitted-models-1">Methods applied to fitted models</a></li><li><a class="toctext" href="#Minimal-examples-1">Minimal examples</a></li><li><a class="toctext" href="#API-1">API</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>GLM Documentation</a></li></ul><a class="edit-page" href="https://github.com/JuliaStats/GLM.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>GLM Documentation</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="GLM-Documentation-1" href="#GLM-Documentation-1">GLM Documentation</a></h1><h2><a class="nav-anchor" id="Installation-1" href="#Installation-1">Installation</a></h2><pre><code class="language-julia">Pkg.add(&quot;GLM&quot;)</code></pre><p>will install this package and its dependencies, which includes the <a href="https://github.com/JuliaStats/Distributions.jl">Distributions package</a>.</p><p>The <a href="https://github.com/johnmyleswhite/RDatasets.jl">RDatasets package</a> is useful for fitting models on standard R datasets to compare the results with those from R.</p><h2><a class="nav-anchor" id="Fitting-GLM-models-1" href="#Fitting-GLM-models-1">Fitting GLM models</a></h2><p>To fit a Generalized Linear Model (GLM), use the function, <code>glm(formula, data, family, link)</code>, where,</p><ul><li><code>formula</code>: uses column symbols from the DataFrame data, for example, if <code>names(data)=[:Y,:X1,:X2]</code>, then a valid formula is <code>@formula(Y ~ X1 + X2)</code></li><li><code>data</code>: a DataFrame which may contain NA values, any rows with NA values are ignored</li><li><code>family</code>: chosen from <code>Bernoulli()</code>, <code>Binomial()</code>, <code>Gamma()</code>, <code>Normal()</code>, <code>Poisson()</code>, or <code>NegativeBinomial(θ)</code></li><li><code>link</code>: chosen from the list below, for example, <code>LogitLink()</code> is a valid link for the <code>Binomial()</code> family</li></ul><p>The <code>NegativeBinomial</code> distribution belongs to the exponential family only if θ (the shape parameter) is fixed, thus θ has to be provided if we use <code>glm</code> with <code>NegativeBinomial</code> family.  If one would like to also estimate θ, then <code>negbin(formula, data, link)</code> should be used instead.</p><p>An intercept is included in any GLM by default.</p><h2><a class="nav-anchor" id="Methods-applied-to-fitted-models-1" href="#Methods-applied-to-fitted-models-1">Methods applied to fitted models</a></h2><p>Many of the methods provided by this package have names similar to those in <a href="http://www.r-project.org">R</a>.</p><ul><li><code>coef</code>: extract the estimates of the coefficients in the model</li><li><code>deviance</code>: measure of the model fit, weighted residual sum of squares for lm&#39;s</li><li><code>dof_residual</code>: degrees of freedom for residuals, when meaningful</li><li><code>glm</code>: fit a generalized linear model (an alias for <code>fit(GeneralizedLinearModel, ...)</code>)</li><li><code>lm</code>: fit a linear model (an alias for <code>fit(LinearModel, ...)</code>)</li><li><code>stderror</code>: standard errors of the coefficients</li><li><code>vcov</code>: estimated variance-covariance matrix of the coefficient estimates</li><li><code>predict</code> : obtain predicted values of the dependent variable from the fitted model</li></ul><h2><a class="nav-anchor" id="Minimal-examples-1" href="#Minimal-examples-1">Minimal examples</a></h2><h3><a class="nav-anchor" id="Ordinary-Least-Squares-Regression:-1" href="#Ordinary-Least-Squares-Regression:-1">Ordinary Least Squares Regression:</a></h3><pre><code class="language-julia-repl">julia&gt; using DataFrames, GLM

julia&gt; data = DataFrame(X=[1,2,3], Y=[2,4,7])
3×2 DataFrames.DataFrame
│ Row │ X     │ Y     │
│     │ Int64 │ Int64 │
├─────┼───────┼───────┤
│ 1   │ 1     │ 2     │
│ 2   │ 2     │ 4     │
│ 3   │ 3     │ 7     │

julia&gt; ols = lm(@formula(Y ~ X), data)
StatsModels.DataFrameRegressionModel{LinearModel{LmResp{Array{Float64,1}},DensePredChol{Float64,LinearAlgebra.Cholesky{Float64,Array{Float64,2}}}},Array{Float64,2}}

Formula: Y ~ 1 + X

Coefficients:
              Estimate Std.Error  t value Pr(&gt;|t|)
(Intercept)  -0.666667   0.62361 -1.06904   0.4788
X                  2.5  0.288675  8.66025   0.0732

julia&gt; round.(stderror(ols), digits=5)
2-element Array{Float64,1}:
 0.62361
 0.28868

julia&gt; round.(predict(ols), digits=5)
3-element Array{Float64,1}:
 1.83333
 4.33333
 6.83333</code></pre><p>&lt;!– Andreas Noack: As of 9 May 2018 (and again 16 January 2019) this example (still) doesn&#39;t work so I&#39;ve temporarily commented it out julia&gt; newX = DataFrame(X=[2,3,4]);</p><p>julia&gt; predict(ols, newX, interval=:confidence)  3×3 Array{Float64,2}:   4.33333  1.33845   7.32821   6.83333  2.09801  11.5687   9.33333  1.40962  17.257</p><pre><code class="language-none">
The columns of the matrix are prediction, 95% lower and upper confidence bounds--&gt;
.

### Probit Regression:</code></pre><p>jldoctest julia&gt; data = DataFrame(X=[1,2,3], Y=[1,0,1]) 3×2 DataFrames.DataFrame │ Row │ X │ Y │ ├─────┼───┼───┤ │ 1   │ 1 │ 1 │ │ 2   │ 2 │ 0 │ │ 3   │ 3 │ 1 │</p><p>julia&gt; probit = glm(@formula(Y ~ X), data, Binomial(), ProbitLink()) StatsModels.DataFrameRegressionModel{GLM.GeneralizedLinearModel{GLM.GlmResp{Array{Float64,1},Distributions.Binomial{Float64},GLM.ProbitLink},GLM.DensePredChol{Float64,Base.LinAlg.Cholesky{Float64,Array{Float64,2}}}},Array{Float64,2}}</p><p>Formula: Y ~ 1 + X</p><p>Coefficients:                  Estimate Std.Error      z value Pr(&gt;|z|) (Intercept)      0.430727   1.98019     0.217518   0.8278 X            -3.64399e-19   0.91665 -3.97534e-19   1.0000</p><pre><code class="language-none">
### Negative Binomial Regression:</code></pre><p>jldoctest julia&gt; using GLM, RDatasets</p><p>julia&gt; quine = dataset(&quot;MASS&quot;, &quot;quine&quot;)</p><p>julia&gt; nbrmodel = glm(@formula(Days ~ Eth+Sex+Age+Lrn), quine, NegativeBinomial(2.0), LogLink()) StatsModels.DataFrameRegressionModel{GLM.GeneralizedLinearModel{GLM.GlmResp{Array{Float64,1},Distributions.NegativeBinomial{Float64},GLM.LogLink},GLM.DensePredChol{Float64,Base.LinAlg.Cholesky{Float64,Array{Float64,2}}}},Array{Float64,2}}</p><p>Formula: Days ~ 1 + Eth + Sex + Age + Lrn</p><p>Coefficients:               Estimate Std.Error  z value Pr(&gt;|z|) (Intercept)    2.88645  0.227144  12.7076   &lt;1e-36 Eth: N       -0.567515  0.152449 -3.72265   0.0002 Sex: M       0.0870771  0.159025 0.547568   0.5840 Age: F1      -0.445076  0.239087 -1.86157   0.0627 Age: F2      0.0927999  0.234502 0.395731   0.6923 Age: F3       0.359485  0.246586  1.45785   0.1449 Lrn: SL       0.296768  0.185934  1.59609   0.1105</p><p>julia&gt; nbrmodel = negbin(@formula(Days ~ Eth+Sex+Age+Lrn), quine, LogLink()) StatsModels.DataFrameRegressionModel{GLM.GeneralizedLinearModel{GLM.GlmResp{Array{Float64,1},Distributions.NegativeBinomial{Float64},GLM.LogLink},GLM.DensePredChol{Float64,Base.LinAlg.Cholesky{Float64,Array{Float64,2}}}},Array{Float64,2}}</p><p>Formula: Days ~ 1 + Eth + Sex + Age + Lrn</p><p>Coefficients:               Estimate Std.Error  z value Pr(&gt;|z|) (Intercept)    2.89453  0.227415   12.728   &lt;1e-36 Eth: N       -0.569341  0.152656 -3.72957   0.0002 Sex: M       0.0823881  0.159209 0.517485   0.6048 Age: F1      -0.448464  0.238687 -1.87888   0.0603 Age: F2      0.0880506  0.235149 0.374445   0.7081 Age: F3       0.356955  0.247228  1.44383   0.1488 Lrn: SL       0.292138   0.18565  1.57359   0.1156</p><p>julia&gt; println(&quot;Estimated theta = &quot;, nbrmodel.model.rr.d.r) Estimated theta = 1.2748930396601978</p><pre><code class="language-none">
## Other examples

An example of a simple linear model in R is</code></pre><p>r</p><blockquote><p>coef(summary(lm(optden ~ carb, Formaldehyde)))</p></blockquote><pre><code class="language-none">           Estimate  Std. Error    t value     Pr(&gt;|t|)</code></pre><p>(Intercept) 0.005085714 0.007833679  0.6492115 5.515953e-01 carb        0.876285714 0.013534536 64.7444207 3.409192e-07</p><pre><code class="language-none">The corresponding model with the `GLM` package is
</code></pre><p>jldoctest julia&gt; using GLM, RDatasets</p><p>julia&gt; form = dataset(&quot;datasets&quot;, &quot;Formaldehyde&quot;) 6×2 DataFrames.DataFrame │ Row │ Carb │ OptDen │ ├─────┼──────┼────────┤ │ 1   │ 0.1  │ 0.086  │ │ 2   │ 0.3  │ 0.269  │ │ 3   │ 0.5  │ 0.446  │ │ 4   │ 0.6  │ 0.538  │ │ 5   │ 0.7  │ 0.626  │ │ 6   │ 0.9  │ 0.782  │</p><p>julia&gt; lm1 = fit(LinearModel, @formula(OptDen ~ Carb), form) StatsModels.DataFrameRegressionModel{GLM.LinearModel{GLM.LmResp{Array{Float64,1}},GLM.DensePredChol{Float64,Base.LinAlg.Cholesky{Float64,Array{Float64,2}}}},Array{Float64,2}}</p><p>Formula: OptDen ~ 1 + Carb</p><p>Coefficients:                Estimate  Std.Error  t value Pr(&gt;|t|) (Intercept)  0.00508571 0.00783368 0.649211   0.5516 Carb           0.876286  0.0135345  64.7444    &lt;1e-6</p><p>julia&gt; confint(lm1) 2×2 Array{Float64,2}:  -0.0166641  0.0268355   0.838708   0.913864</p><pre><code class="language-none">
A more complex example in R is</code></pre><p>r</p><blockquote><p>coef(summary(lm(sr ~ pop15 + pop75 + dpi + ddpi, LifeCycleSavings)))</p></blockquote><pre><code class="language-none">             Estimate   Std. Error    t value     Pr(&gt;|t|)</code></pre><p>(Intercept) 28.5660865407 7.3545161062  3.8841558 0.0003338249 pop15       -0.4611931471 0.1446422248 -3.1885098 0.0026030189 pop75       -1.6914976767 1.0835989307 -1.5609998 0.1255297940 dpi         -0.0003369019 0.0009311072 -0.3618293 0.7191731554 ddpi         0.4096949279 0.1961971276  2.0881801 0.0424711387</p><pre><code class="language-none">with the corresponding Julia code</code></pre><p>jldoctest julia&gt; LifeCycleSavings = dataset(&quot;datasets&quot;, &quot;LifeCycleSavings&quot;) 50×6 DataFrames.DataFrame │ Row │ Country        │ SR    │ Pop15 │ Pop75 │ DPI     │ DDPI  │ ├─────┼────────────────┼───────┼───────┼───────┼─────────┼───────┤ │ 1   │ Australia      │ 11.43 │ 29.35 │ 2.87  │ 2329.68 │ 2.87  │ │ 2   │ Austria        │ 12.07 │ 23.32 │ 4.41  │ 1507.99 │ 3.93  │ │ 3   │ Belgium        │ 13.17 │ 23.8  │ 4.43  │ 2108.47 │ 3.82  │ │ 4   │ Bolivia        │ 5.75  │ 41.89 │ 1.67  │ 189.13  │ 0.22  │ │ 5   │ Brazil         │ 12.88 │ 42.19 │ 0.83  │ 728.47  │ 4.56  │ │ 6   │ Canada         │ 8.79  │ 31.72 │ 2.85  │ 2982.88 │ 2.43  │ │ 7   │ Chile          │ 0.6   │ 39.74 │ 1.34  │ 662.86  │ 2.67  │ │ 8   │ China          │ 11.9  │ 44.75 │ 0.67  │ 289.52  │ 6.51  │ ⋮ │ 42  │ Tunisia        │ 2.81  │ 46.12 │ 1.21  │ 249.87  │ 1.13  │ │ 43  │ United Kingdom │ 7.81  │ 23.27 │ 4.46  │ 1813.93 │ 2.01  │ │ 44  │ United States  │ 7.56  │ 29.81 │ 3.43  │ 4001.89 │ 2.45  │ │ 45  │ Venezuela      │ 9.22  │ 46.4  │ 0.9   │ 813.39  │ 0.53  │ │ 46  │ Zambia         │ 18.56 │ 45.25 │ 0.56  │ 138.33  │ 5.14  │ │ 47  │ Jamaica        │ 7.72  │ 41.12 │ 1.73  │ 380.47  │ 10.23 │ │ 48  │ Uruguay        │ 9.24  │ 28.13 │ 2.72  │ 766.54  │ 1.88  │ │ 49  │ Libya          │ 8.89  │ 43.69 │ 2.07  │ 123.58  │ 16.71 │ │ 50  │ Malaysia       │ 4.71  │ 47.2  │ 0.66  │ 242.69  │ 5.08  │</p><p>julia&gt; fm2 = fit(LinearModel, @formula(SR ~ Pop15 + Pop75 + DPI + DDPI), LifeCycleSavings) StatsModels.DataFrameRegressionModel{GLM.LinearModel{GLM.LmResp{Array{Float64,1}},GLM.DensePredChol{Float64,Base.LinAlg.Cholesky{Float64,Array{Float64,2}}}},Array{Float64,2}}</p><p>Formula: SR ~ 1 + Pop15 + Pop75 + DPI + DDPI</p><p>Coefficients:                  Estimate   Std.Error   t value Pr(&gt;|t|) (Intercept)       28.5661     7.35452   3.88416   0.0003 Pop15           -0.461193    0.144642  -3.18851   0.0026 Pop75             -1.6915      1.0836    -1.561   0.1255 DPI          -0.000336902 0.000931107 -0.361829   0.7192 DDPI             0.409695    0.196197   2.08818   0.0425</p><pre><code class="language-none">
The `glm` function (or equivalently, `fit(GeneralizedLinearModel, ...)`)
works similarly to the R `glm` function except that the `family`
argument is replaced by a `Distribution` type and, optionally, a `Link` type.
The first example from `?glm` in R is
</code></pre><p>r glm&gt; ## Dobson (1990) Page 93: Randomized Controlled Trial : glm&gt; counts &lt;- c(18,17,15,20,10,20,25,13,12)</p><p>glm&gt; outcome &lt;- gl(3,1,9)</p><p>glm&gt; treatment &lt;- gl(3,3)</p><p>glm&gt; print(d.AD &lt;- data.frame(treatment, outcome, counts))   treatment outcome counts 1         1       1     18 2         1       2     17 3         1       3     15 4         2       1     20 5         2       2     10 6         2       3     20 7         3       1     25 8         3       2     13 9         3       3     12</p><p>glm&gt; glm.D93 &lt;- glm(counts ~ outcome + treatment, family=poisson())</p><p>glm&gt; anova(glm.D93) Analysis of Deviance Table</p><p>Model: poisson, link: log</p><p>Response: counts</p><p>Terms added sequentially (first to last)</p><pre><code class="language-none">      Df Deviance Resid. Df Resid. Dev</code></pre><p>NULL                          8    10.5814 outcome    2   5.4523         6     5.1291 treatment  2   0.0000         4     5.1291</p><p>glm&gt; ## No test: glm&gt; summary(glm.D93)</p><p>Call: glm(formula = counts ~ outcome + treatment, family = poisson())</p><p>Deviance Residuals:        1         2         3         4         5         6         7         8   -0.67125   0.96272  -0.16965  -0.21999  -0.95552   1.04939   0.84715  -0.09167          9   -0.96656  </p><p>Coefficients:               Estimate Std. Error z value Pr(&gt;|z|)     (Intercept)  3.045e+00  1.709e-01  17.815   &lt;2e-16 *** outcome2    -4.543e-01  2.022e-01  -2.247   0.0246 *   outcome3    -2.930e-01  1.927e-01  -1.520   0.1285     treatment2   3.795e-16  2.000e-01   0.000   1.0000     treatment3   3.553e-16  2.000e-01   0.000   1.0000     –- Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1</p><p>(Dispersion parameter for poisson family taken to be 1)</p><pre><code class="language-none">Null deviance: 10.5814  on 8  degrees of freedom</code></pre><p>Residual deviance:  5.1291  on 4  degrees of freedom AIC: 56.761</p><p>Number of Fisher Scoring iterations: 4</p><pre><code class="language-none">In Julia this becomes</code></pre><p>jldoctest julia&gt; using DataFrames, CategoricalArrays, GLM</p><p>julia&gt; dobson = DataFrame(Counts    = [18.,17,15,20,10,20,25,13,12],                           Outcome   = categorical([1,2,3,1,2,3,1,2,3]),                           Treatment = categorical([1,1,1,2,2,2,3,3,3])) 9×3 DataFrames.DataFrame │ Row │ Counts │ Outcome │ Treatment │ ├─────┼────────┼─────────┼───────────┤ │ 1   │ 18.0   │ 1       │ 1         │ │ 2   │ 17.0   │ 2       │ 1         │ │ 3   │ 15.0   │ 3       │ 1         │ │ 4   │ 20.0   │ 1       │ 2         │ │ 5   │ 10.0   │ 2       │ 2         │ │ 6   │ 20.0   │ 3       │ 2         │ │ 7   │ 25.0   │ 1       │ 3         │ │ 8   │ 13.0   │ 2       │ 3         │ │ 9   │ 12.0   │ 3       │ 3         │</p><p>julia&gt; gm1 = fit(GeneralizedLinearModel, @formula(Counts ~ Outcome + Treatment), dobson, Poisson()) StatsModels.DataFrameRegressionModel{GLM.GeneralizedLinearModel{GLM.GlmResp{Array{Float64,1},Distributions.Poisson{Float64},GLM.LogLink},GLM.DensePredChol{Float64,Base.LinAlg.Cholesky{Float64,Array{Float64,2}}}},Array{Float64,2}}</p><p>Formula: Counts ~ 1 + Outcome + Treatment</p><p>Coefficients:                  Estimate Std.Error     z value Pr(&gt;|z|) (Intercept)       3.04452  0.170899     17.8148   &lt;1e-70 Outcome: 2      -0.454255  0.202171    -2.24689   0.0246 Outcome: 3      -0.292987  0.192742     -1.5201   0.1285 Treatment: 2  4.61065e-16       0.2 2.30532e-15   1.0000 Treatment: 3  3.44687e-17       0.2 1.72344e-16   1.0000</p><p>julia&gt; deviance(gm1) 5.129141077001145</p><pre><code class="language-none">
Typical distributions for use with `glm` and their canonical link
functions are

           Bernoulli (LogitLink)
            Binomial (LogitLink)
               Gamma (InverseLink)
     InverseGaussian (InverseSquareLink)
    NegativeBinomial (LogLink)
              Normal (IdentityLink)
             Poisson (LogLink)

Currently the available Link types are

    CauchitLink
    CloglogLink
    IdentityLink
    InverseLink
    InverseSquareLink
    LogitLink
    LogLink
    NegativeBinomialLink
    ProbitLink
    SqrtLink

Note that the canonical link for negative binomial regression is `NegativeBinomialLink`, but
in practice one typically uses `LogLink`.

## Separation of response object and predictor object

The general approach in this code is to separate functionality related
to the response from that related to the linear predictor.  This
allows for greater generality by mixing and matching different
subtypes of the abstract type ```LinPred``` and the abstract type ```ModResp```.

A ```LinPred``` type incorporates the parameter vector and the model
matrix.  The parameter vector is a dense numeric vector but the model
matrix can be dense or sparse.  A ```LinPred``` type must incorporate
some form of a decomposition of the weighted model matrix that allows
for the solution of a system ```X&#39;W * X * delta=X&#39;wres``` where ```W``` is a
diagonal matrix of &quot;X weights&quot;, provided as a vector of the square
roots of the diagonal elements, and ```wres``` is a weighted residual vector.

Currently there are two dense predictor types, ```DensePredQR``` and</code></pre><p>DensePredChol```, and the usual caveats apply.  The Cholesky version is faster but somewhat less accurate than that QR version. The skeleton of a distributed predictor type is in the code but not yet fully fleshed out.  Because Julia by default uses OpenBLAS, which is already multi-threaded on multicore machines, there may not be much advantage in using distributed predictor types.</p><p>A <code>ModResp</code> type must provide methods for the <code>wtres</code> and <code>sqrtxwts</code> generics.  Their values are the arguments to the <code>updatebeta</code> methods of the <code>LinPred</code> types.  The <code>Float64</code> value returned by <code>updatedelta</code> is the value of the convergence criterion.</p><p>Similarly, <code>LinPred</code> types must provide a method for the <code>linpred</code> generic.  In general <code>linpred</code> takes an instance of a <code>LinPred</code> type and a step factor.  Methods that take only an instance of a <code>LinPred</code> type use a default step factor of 1.  The value of <code>linpred</code> is the argument to the <code>updatemu</code> method for <code>ModResp</code> types.  The <code>updatemu</code> method returns the updated deviance.</p><h2><a class="nav-anchor" id="API-1" href="#API-1">API</a></h2><h3><a class="nav-anchor" id="Types-defined-in-the-package-1" href="#Types-defined-in-the-package-1">Types defined in the package</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.DensePredChol" href="#GLM.DensePredChol"><code>GLM.DensePredChol</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">DensePredChol{T}</code></pre><p>A <code>LinPred</code> type with a dense Cholesky factorization of <code>X&#39;X</code></p><p><strong>Members</strong></p><ul><li><code>X</code>: model matrix of size <code>n</code> × <code>p</code> with <code>n ≥ p</code>.  Should be full column rank.</li><li><code>beta0</code>: base coefficient vector of length <code>p</code></li><li><code>delbeta</code>: increment to coefficient vector, also of length <code>p</code></li><li><code>scratchbeta</code>: scratch vector of length <code>p</code>, used in <a href="#GLM.linpred!"><code>linpred!</code></a> method</li><li><code>chol</code>: a <code>Cholesky</code> object created from <code>X&#39;X</code>, possibly using row weights.</li><li><code>scratchm1</code>: scratch Matrix{T} of the same size as <code>X</code></li><li><code>scratchm2</code>: scratch Matrix{T} os the same size as <code>X&#39;X</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/956a64e7df79e80405867238781f24567bd40c78/src/linpred.jl#L80-L94">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.DensePredQR" href="#GLM.DensePredQR"><code>GLM.DensePredQR</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">DensePredQR</code></pre><p>A <code>LinPred</code> type with a dense, unpivoted QR decomposition of <code>X</code></p><p><strong>Members</strong></p><ul><li><code>X</code>: Model matrix of size <code>n</code> × <code>p</code> with <code>n ≥ p</code>.  Should be full column rank.</li><li><code>beta0</code>: base coefficient vector of length <code>p</code></li><li><code>delbeta</code>: increment to coefficient vector, also of length <code>p</code></li><li><code>scratchbeta</code>: scratch vector of length <code>p</code>, used in <a href="#GLM.linpred!"><code>linpred!</code></a> method</li><li><code>qr</code>: a <code>QRCompactWY</code> object created from <code>X</code>, with optional row weights.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/956a64e7df79e80405867238781f24567bd40c78/src/linpred.jl#L35-L47">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.GlmResp" href="#GLM.GlmResp"><code>GLM.GlmResp</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">GlmResp</code></pre><p>The response vector and various derived vectors in a generalized linear model.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/956a64e7df79e80405867238781f24567bd40c78/src/glmfit.jl#L1-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.LinearModel" href="#GLM.LinearModel"><code>GLM.LinearModel</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">LinearModel</code></pre><p>A combination of a <a href="#GLM.LmResp"><code>LmResp</code></a> and a <a href="#GLM.LinPred"><code>LinPred</code></a></p><p><strong>Members</strong></p><ul><li><code>rr</code>: a <code>LmResp</code> object</li><li><code>pp</code>: a <code>LinPred</code> object</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/956a64e7df79e80405867238781f24567bd40c78/src/lm.jl#L111-L120">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.LmResp" href="#GLM.LmResp"><code>GLM.LmResp</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">LmResp</code></pre><p>Encapsulates the response for a linear model</p><p><strong>Members</strong></p><ul><li><code>mu</code>: current value of the mean response vector or fitted value</li><li><code>offset</code>: optional offset added to the linear predictor to form <code>mu</code></li><li><code>wts</code>: optional vector of prior weights</li><li><code>y</code>: observed response vector</li></ul><p>Either or both <code>offset</code> and <code>wts</code> may be of length 0</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/956a64e7df79e80405867238781f24567bd40c78/src/lm.jl#L1-L14">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.LinPred" href="#GLM.LinPred"><code>GLM.LinPred</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">LinPred</code></pre><p>Abstract type representing a linear predictor</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/956a64e7df79e80405867238781f24567bd40c78/src/GLM.jl#L87-L91">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.ModResp" href="#GLM.ModResp"><code>GLM.ModResp</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ModResp</code></pre><p>Abstract type representing a model response vector</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/956a64e7df79e80405867238781f24567bd40c78/src/GLM.jl#L80-L84">source</a></section><h3><a class="nav-anchor" id="Constructors-for-models-1" href="#Constructors-for-models-1">Constructors for models</a></h3><p>The most general approach to fitting a model is with the <code>fit</code> function, as in</p><pre><code class="language-julia-repl">julia&gt; using Random;

julia&gt; fit(LinearModel, hcat(ones(10), 1:10), randn(MersenneTwister(12321), 10))
LinearModel{LmResp{Array{Float64,1}},DensePredChol{Float64,LinearAlgebra.Cholesky{Float64,Array{Float64,2}}}}:

Coefficients:
      Estimate Std.Error  t value Pr(&gt;|t|)
x1    0.717436  0.775175 0.925515   0.3818
x2   -0.152062  0.124931 -1.21717   0.2582</code></pre><p>This model can also be fit as</p><pre><code class="language-julia-repl">julia&gt; using Random;

julia&gt; lm(hcat(ones(10), 1:10), randn(MersenneTwister(12321), 10))
LinearModel{LmResp{Array{Float64,1}},DensePredChol{Float64,LinearAlgebra.Cholesky{Float64,Array{Float64,2}}}}:

Coefficients:
      Estimate Std.Error  t value Pr(&gt;|t|)
x1    0.717436  0.775175 0.925515   0.3818
x2   -0.152062  0.124931 -1.21717   0.2582</code></pre><h3><a class="nav-anchor" id="Model-methods-1" href="#Model-methods-1">Model methods</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.cancancel" href="#GLM.cancancel"><code>GLM.cancancel</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">cancancel(r::GlmResp{V,D,L})</code></pre><p>Returns <code>true</code> if dμ/dη for link <code>L</code> is the variance function for distribution <code>D</code></p><p>When <code>L</code> is the canonical link for <code>D</code> the derivative of the inverse link is a multiple of the variance function for <code>D</code>.  If they are the same a numerator and denominator term in the expression for the working weights will cancel.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/956a64e7df79e80405867238781f24567bd40c78/src/glmfit.jl#L63-L71">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.delbeta!" href="#GLM.delbeta!"><code>GLM.delbeta!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">delbeta!(p::LinPred, r::Vector)</code></pre><p>Evaluate and return <code>p.delbeta</code> the increment to the coefficient vector from residual <code>r</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/956a64e7df79e80405867238781f24567bd40c78/src/linpred.jl#L68-L72">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.deviance" href="#StatsBase.deviance"><code>StatsBase.deviance</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">deviance(obj::LinearModel)</code></pre><p>For linear models, the deviance is equal to the residual sum of squares (RSS).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/956a64e7df79e80405867238781f24567bd40c78/src/lm.jl#L152-L156">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.dispersion" href="#GLM.dispersion"><code>GLM.dispersion</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dispersion(m::AbstractGLM, sqr::Bool=false)</code></pre><p>Return the estimated dispersion (or scale) parameter for a model&#39;s distribution, generally written σ² for linear models and ϕ for generalized linear models. It is, by definition, equal to 1 for the Bernoulli, Binomial, and Poisson families.</p><p>If <code>sqr</code> is <code>true</code>, the squared dispersion parameter is returned.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/956a64e7df79e80405867238781f24567bd40c78/src/glmfit.jl#L336-L344">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.installbeta!" href="#GLM.installbeta!"><code>GLM.installbeta!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">installbeta!(p::LinPred, f::Real=1.0)</code></pre><p>Install <code>pbeta0 .+= f * p.delbeta</code> and zero out <code>p.delbeta</code>.  Return the updated <code>p.beta0</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/956a64e7df79e80405867238781f24567bd40c78/src/linpred.jl#L20-L24">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.issubmodel" href="#GLM.issubmodel"><code>GLM.issubmodel</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>A helper function to determine if mod1 is nested in mod2</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/956a64e7df79e80405867238781f24567bd40c78/src/ftest.jl#L10">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.linpred!" href="#GLM.linpred!"><code>GLM.linpred!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">linpred!(out, p::LinPred, f::Real=1.0)</code></pre><p>Overwrite <code>out</code> with the linear predictor from <code>p</code> with factor <code>f</code></p><p>The effective coefficient vector, <code>p.scratchbeta</code>, is evaluated as <code>p.beta0 .+ f * p.delbeta</code>, and <code>out</code> is updated to <code>p.X * p.scratchbeta</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/956a64e7df79e80405867238781f24567bd40c78/src/linpred.jl#L1-L8">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.linpred" href="#GLM.linpred"><code>GLM.linpred</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">linpred(p::LinPred, f::Read=1.0)</code></pre><p>Return the linear predictor <code>p.X * (p.beta0 .+ f * p.delbeta)</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/956a64e7df79e80405867238781f24567bd40c78/src/linpred.jl#L13-L17">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.lm" href="#GLM.lm"><code>GLM.lm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">lm(X, y, allowrankdeficient::Bool=false)</code></pre><p>An alias for <code>fit(LinearModel, X, y, allowrankdeficient)</code></p><p>The arguments <code>X</code> and <code>y</code> can be a <code>Matrix</code> and a <code>Vector</code> or a <code>Formula</code> and a <code>DataFrame</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/956a64e7df79e80405867238781f24567bd40c78/src/lm.jl#L139-L145">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.nobs" href="#StatsBase.nobs"><code>StatsBase.nobs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">nobs(obj::LinearModel)
nobs(obj::GLM)</code></pre><p>For linear and generalized linear models, returns the number of rows, or, when prior weights are specified, the sum of weights.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/956a64e7df79e80405867238781f24567bd40c78/src/linpred.jl#L238-L244">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.nulldeviance" href="#StatsBase.nulldeviance"><code>StatsBase.nulldeviance</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">nulldeviance(obj::LinearModel)</code></pre><p>For linear models, the deviance of the null model is equal to the total sum of squares (TSS).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/956a64e7df79e80405867238781f24567bd40c78/src/lm.jl#L159-L163">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.predict" href="#StatsBase.predict"><code>StatsBase.predict</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">predict(mm::LinearModel, newx::AbstractMatrix;
        interval::Union{Symbol,Nothing} = nothing, level::Real = 0.95)</code></pre><p>If <code>interval</code> is <code>nothing</code> (the default), return a vector with the predicted values for model <code>mm</code> and new data <code>newx</code>. Otherwise, return a 3-column matrix with the prediction and the lower and upper confidence bounds for a given <code>level</code> (0.95 equates alpha = 0.05). Valid values of <code>interval</code> are <code>:confidence</code> delimiting the  uncertainty of the predicted relationship, and <code>:prediction</code> delimiting estimated bounds for new data points.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/956a64e7df79e80405867238781f24567bd40c78/src/lm.jl#L191-L201">source</a><div><div><pre><code class="language-none">predict(mm::AbstractGLM, newX::AbstractMatrix; offset::FPVector=Vector{eltype(newX)}(0))</code></pre><p>Form the predicted response of model <code>mm</code> from covariate values <code>newX</code> and, optionally, an offset.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/956a64e7df79e80405867238781f24567bd40c78/src/glmfit.jl#L356-L361">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.updateμ!" href="#GLM.updateμ!"><code>GLM.updateμ!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">updateμ!{T&lt;:FPVector}(r::GlmResp{T}, linPr::T)</code></pre><p>Update the mean, working weights and working residuals, in <code>r</code> given a value of the linear predictor, <code>linPr</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/956a64e7df79e80405867238781f24567bd40c78/src/glmfit.jl#L78-L83">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.wrkresp" href="#GLM.wrkresp"><code>GLM.wrkresp</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">wrkresp(r::GlmResp)</code></pre><p>The working response, <code>r.eta + r.wrkresid - r.offset</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/956a64e7df79e80405867238781f24567bd40c78/src/glmfit.jl#L136-L140">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.wrkresp!" href="#GLM.wrkresp!"><code>GLM.wrkresp!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">wrkresp!{T&lt;:FPVector}(v::T, r::GlmResp{T})</code></pre><p>Overwrite <code>v</code> with the working response of <code>r</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/956a64e7df79e80405867238781f24567bd40c78/src/glmfit.jl#L143-L147">source</a></section><p>&lt;!– ftest should be included as well but currently Documenter can&#39;t parse the doctest for ftest–&gt;</p><h3><a class="nav-anchor" id="Links-and-methods-applied-to-them-1" href="#Links-and-methods-applied-to-them-1">Links and methods applied to them</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.Link" href="#GLM.Link"><code>GLM.Link</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Link</code></pre><p>An abstract type whose subtypes determine methods for <a href="#GLM.linkfun"><code>linkfun</code></a>, <a href="#GLM.linkinv"><code>linkinv</code></a>, <a href="#GLM.mueta"><code>mueta</code></a>, and <a href="#GLM.inverselink"><code>inverselink</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/956a64e7df79e80405867238781f24567bd40c78/src/glmtools.jl#L1-L6">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.Link01" href="#GLM.Link01"><code>GLM.Link01</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Link01</code></pre><p>An abstract subtype of <a href="#GLM.Link"><code>Link</code></a> which are links defined on (0, 1)</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/956a64e7df79e80405867238781f24567bd40c78/src/glmtools.jl#L12-L16">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.CauchitLink" href="#GLM.CauchitLink"><code>GLM.CauchitLink</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">CauchitLink</code></pre><p>A <a href="#GLM.Link01"><code>Link01</code></a> corresponding to the standard Cauchy distribution, <a href="https://juliastats.github.io/Distributions.jl/stable/univariate.html#Distributions.Cauchy"><code>Distributions.Cauchy</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/956a64e7df79e80405867238781f24567bd40c78/src/glmtools.jl#L19-L24">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.CloglogLink" href="#GLM.CloglogLink"><code>GLM.CloglogLink</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">CloglogLink</code></pre><p>A <a href="#GLM.Link01"><code>Link01</code></a> corresponding to the extreme value (or log-Wiebull) distribution.  The link is the complementary log-log transformation, <code>log(1 - log(-μ))</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/956a64e7df79e80405867238781f24567bd40c78/src/glmtools.jl#L27-L32">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.IdentityLink" href="#GLM.IdentityLink"><code>GLM.IdentityLink</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">IdentityLink</code></pre><p>The canonical <a href="#GLM.Link"><code>Link</code></a> for the <code>Normal</code> distribution, defined as <code>η = μ</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/956a64e7df79e80405867238781f24567bd40c78/src/glmtools.jl#L35-L39">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.InverseLink" href="#GLM.InverseLink"><code>GLM.InverseLink</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">InverseLink</code></pre><p>The canonical <a href="#GLM.Link"><code>Link</code></a> for <a href="https://juliastats.github.io/Distributions.jl/stable/univariate.html#Distributions.Gamma"><code>Distributions.Gamma</code></a> distribution, defined as <code>η = inv(μ)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/956a64e7df79e80405867238781f24567bd40c78/src/glmtools.jl#L42-L46">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.InverseSquareLink" href="#GLM.InverseSquareLink"><code>GLM.InverseSquareLink</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">InverseSquareLink</code></pre><p>The canonical <a href="#GLM.Link"><code>Link</code></a> for <a href="https://juliastats.github.io/Distributions.jl/stable/univariate.html#Distributions.InverseGaussian"><code>Distributions.InverseGaussian</code></a> distribution, defined as <code>η = inv(abs2(μ))</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/956a64e7df79e80405867238781f24567bd40c78/src/glmtools.jl#L49-L53">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.LogitLink" href="#GLM.LogitLink"><code>GLM.LogitLink</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">LogitLink</code></pre><p>The canonical <a href="#GLM.Link01"><code>Link01</code></a> for <a href="https://juliastats.github.io/Distributions.jl/stable/univariate.html#Distributions.Bernoulli"><code>Distributions.Bernoulli</code></a> and <a href="https://juliastats.github.io/Distributions.jl/stable/univariate.html#Distributions.Binomial"><code>Distributions.Binomial</code></a>. The inverse link, <a href="#GLM.linkinv"><code>linkinv</code></a>, is the c.d.f. of the standard logistic distribution, <a href="https://juliastats.github.io/Distributions.jl/stable/univariate.html#Distributions.Logistic"><code>Distributions.Logistic</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/956a64e7df79e80405867238781f24567bd40c78/src/glmtools.jl#L56-L62">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.LogLink" href="#GLM.LogLink"><code>GLM.LogLink</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">LogLink</code></pre><p>The canonical <a href="#GLM.Link"><code>Link</code></a> for <a href="https://juliastats.github.io/Distributions.jl/stable/univariate.html#Distributions.Poisson"><code>Distributions.Poisson</code></a>, defined as <code>η = log(μ)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/956a64e7df79e80405867238781f24567bd40c78/src/glmtools.jl#L65-L69">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.NegativeBinomialLink" href="#GLM.NegativeBinomialLink"><code>GLM.NegativeBinomialLink</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">NegativeBinomialLink</code></pre><p>The canonical <a href="#GLM.Link"><code>Link</code></a> for <a href="https://juliastats.github.io/Distributions.jl/stable/univariate.html#Distributions.NegativeBinomial"><code>Distributions.NegativeBinomial</code></a> distribution, defined as <code>η = log(μ/(μ+θ))</code>. The shape parameter θ has to be fixed for the distribution to belong to the exponential family.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/956a64e7df79e80405867238781f24567bd40c78/src/glmtools.jl#L72-L77">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.ProbitLink" href="#GLM.ProbitLink"><code>GLM.ProbitLink</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ProbitLink</code></pre><p>A <a href="#GLM.Link01"><code>Link01</code></a> whose <a href="#GLM.linkinv"><code>linkinv</code></a> is the c.d.f. of the standard normal distribution, <a href="https://juliastats.github.io/Distributions.jl/stable/univariate.html#Distributions.Normal"><code>Distributions.Normal()</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/956a64e7df79e80405867238781f24567bd40c78/src/glmtools.jl#L82-L87">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.SqrtLink" href="#GLM.SqrtLink"><code>GLM.SqrtLink</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SqrtLink</code></pre><p>A <a href="#GLM.Link"><code>Link</code></a> defined as <code>η = √μ</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/956a64e7df79e80405867238781f24567bd40c78/src/glmtools.jl#L90-L94">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.linkfun" href="#GLM.linkfun"><code>GLM.linkfun</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">linkfun(L::Link, μ)</code></pre><p>Return <code>η</code>, the value of the linear predictor for link <code>L</code> at mean <code>μ</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; μ = inv(10):inv(5):1
0.1:0.2:0.9

julia&gt; show(linkfun.(LogitLink(), μ))
[-2.19722, -0.847298, 0.0, 0.847298, 2.19722]
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/956a64e7df79e80405867238781f24567bd40c78/src/glmtools.jl#L97-L111">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.linkinv" href="#GLM.linkinv"><code>GLM.linkinv</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">linkinv(L::Link, η)</code></pre><p>Return <code>μ</code>, the mean value, for link <code>L</code> at linear predictor value <code>η</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; μ = 0.1:0.2:1
0.1:0.2:0.9

julia&gt; η = logit.(μ);

julia&gt; linkinv.(LogitLink(), η) ≈ μ
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/956a64e7df79e80405867238781f24567bd40c78/src/glmtools.jl#L114-L129">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.mueta" href="#GLM.mueta"><code>GLM.mueta</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">mueta(L::Link, η)</code></pre><p>Return the derivative of <a href="#GLM.linkinv"><code>linkinv</code></a>, <code>dμ/dη</code>, for link <code>L</code> at linear predictor value <code>η</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; mueta(LogitLink(), 0.0)
0.25

julia&gt; mueta(CloglogLink(), 0.0) ≈ 0.36787944117144233
true

julia&gt; mueta(LogLink(), 2.0) ≈ 7.38905609893065
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/956a64e7df79e80405867238781f24567bd40c78/src/glmtools.jl#L132-L148">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.inverselink" href="#GLM.inverselink"><code>GLM.inverselink</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">inverselink(L::Link, η)</code></pre><p>Return a 3-tuple of the inverse link, the derivative of the inverse link, and when appropriate, the variance function <code>μ*(1 - μ)</code>.</p><p>The variance function is returned as NaN unless the range of μ is (0, 1)</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; inverselink(LogitLink(), 0.0)
(0.5, 0.25, 0.25)

julia&gt; μ, oneminusμ, variance = inverselink(CloglogLink(), 0.0);

julia&gt; μ + oneminusμ ≈ 1
true

julia&gt; μ*(1 - μ) ≈ variance
true

julia&gt; isnan(last(inverselink(LogLink(), 2.0)))
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/956a64e7df79e80405867238781f24567bd40c78/src/glmtools.jl#L151-L174">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.canonicallink" href="#GLM.canonicallink"><code>GLM.canonicallink</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">canonicallink(D::Distribution)</code></pre><p>Return the canonical link for distribution <code>D</code>, which must be in the exponential family.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; canonicallink(Bernoulli())
LogitLink()</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/956a64e7df79e80405867238781f24567bd40c78/src/glmtools.jl#L177-L187">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.glmvar" href="#GLM.glmvar"><code>GLM.glmvar</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">glmvar(D::Distribution, μ)</code></pre><p>Return the value of the variance function for <code>D</code> at <code>μ</code></p><p>The variance of <code>D</code> at <code>μ</code> is the product of the dispersion parameter, ϕ, which does not depend on <code>μ</code> and the value of <code>glmvar</code>.  In other words <code>glmvar</code> returns the factor of the variance that depends on <code>μ</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; μ = 1/6:1/3:1;

julia&gt; glmvar.(Normal(), μ)    # constant for Normal()
3-element Array{Float64,1}:
 1.0
 1.0
 1.0

julia&gt; glmvar.(Bernoulli(), μ) ≈ μ .* (1 .- μ)
true

julia&gt; glmvar.(Poisson(), μ) == μ
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/956a64e7df79e80405867238781f24567bd40c78/src/glmtools.jl#L287-L312">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.mustart" href="#GLM.mustart"><code>GLM.mustart</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">mustart(D::Distribution, y, wt)</code></pre><p>Return a starting value for μ.</p><p>For some distributions it is appropriate to set <code>μ = y</code> to initialize the IRLS algorithm but for others, notably the Bernoulli, the values of <code>y</code> are not allowed as values of <code>μ</code> and must be modified.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; mustart(Bernoulli(), 0.0, 1) ≈ 1/4
true

julia&gt; mustart(Bernoulli(), 1.0, 1) ≈ 3/4
true

julia&gt; mustart(Binomial(), 0.0, 10) ≈ 1/22
true

julia&gt; mustart(Normal(), 0.0, 1) ≈ 0
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/956a64e7df79e80405867238781f24567bd40c78/src/glmtools.jl#L322-L345">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.devresid" href="#GLM.devresid"><code>GLM.devresid</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">devresid(D, y, μ)</code></pre><p>Return the squared deviance residual of <code>μ</code> from <code>y</code> for distribution <code>D</code></p><p>The deviance of a GLM can be evaluated as the sum of the squared deviance residuals.  This is the principal use for these values.  The actual deviance residual, say for plotting, is the signed square root of this value</p><pre><code class="language-julia">sign(y - μ) * sqrt(devresid(D, y, μ))</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; devresid(Normal(), 0, 0.25) ≈ abs2(0.25)
true

julia&gt; devresid(Bernoulli(), 1, 0.75) ≈ -2*log(0.75)
true

julia&gt; devresid(Bernoulli(), 0, 0.25) ≈ -2*log1p(-0.25)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/956a64e7df79e80405867238781f24567bd40c78/src/glmtools.jl#L364-L387">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.dispersion_parameter" href="#GLM.dispersion_parameter"><code>GLM.dispersion_parameter</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dispersion_parameter(D)  # not exported</code></pre><p>Does distribution <code>D</code> have a separate dispersion parameter, ϕ?</p><p>Returns <code>false</code> for the <code>Bernoulli</code>, <code>Binomial</code> and <code>Poisson</code> distributions, <code>true</code> otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; show(GLM.dispersion_parameter(Normal()))
true
julia&gt; show(GLM.dispersion_parameter(Bernoulli()))
false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/956a64e7df79e80405867238781f24567bd40c78/src/glmtools.jl#L417-L431">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLM.loglik_obs" href="#GLM.loglik_obs"><code>GLM.loglik_obs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">loglik_obs(D, y, μ, wt, ϕ)  # not exported</code></pre><p>Returns <code>wt * logpdf(D(μ, ϕ), y)</code> where the parameters of <code>D</code> are derived from <code>μ</code> and <code>ϕ</code>.</p><p>The <code>wt</code> argument is a multiplier of the result except in the case of the <code>Binomial</code> where <code>wt</code> is the number of trials and <code>μ</code> is the proportion of successes.</p><p>The loglikelihood of a fitted model is the sum of these values over all the observations.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/GLM.jl/blob/956a64e7df79e80405867238781f24567bd40c78/src/glmtools.jl#L435-L444">source</a></section><footer><hr/></footer></article></body></html>
